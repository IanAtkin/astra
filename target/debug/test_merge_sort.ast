; Astra Script: Fully Recursive Merge Sort (Using Concatenation and Recursion)
; Define the array to be sorted
data_array = ["cherry", "apple", "mango", "banana", "orange", "grape", "kiwi", "lemon"]

; --- Recursive Merge Helper Functions ---

; 1. Recursive function to append remaining elements from the left array
fn append_remaining_left(result, left_arr, left_i) [
    if (left_i >= length(left_arr)) [
        return result
    ]
    
    ; Concatenate the existing result with the new element (wrapped in a new array)
    result = result + [left_arr[left_i]]
    return append_remaining_left(result, left_arr, left_i + 1)
]

; 2. Recursive function to append remaining elements from the right array
fn append_remaining_right(result, right_arr, right_i) [
    if (right_i >= length(right_arr)) [
        return result
    ]
    
    ; Concatenate the existing result with the new element (wrapped in a new array)
    result = result + [right_arr[right_i]]
    return append_remaining_right(result, right_arr, right_i + 1)
]

; 3. Main Recursive Merge function
fn recursive_merge_step(left_arr, left_i, right_arr, right_i, result) [
    
    ; Base Case 1: Left array exhausted, append rest of right array
    if (left_i >= length(left_arr)) [
        return append_remaining_right(result, right_arr, right_i)
    ]
    
    ; Base Case 2: Right array exhausted, append rest of left array
    if (right_i >= length(right_arr)) [
        return append_remaining_left(result, left_arr, left_i)
    ]
    
    ; Recursive Step: Comparison and selection
    if (left_arr[left_i] <= right_arr[right_i]) [
        ; Take from left, advance left index
        result = result + [left_arr[left_i]]
        return recursive_merge_step(left_arr, left_i + 1, right_arr, right_i, result)
    ] else [
        ; Take from right, advance right index
        result = result + [right_arr[right_i]]
        return recursive_merge_step(left_arr, left_i, right_arr, right_i + 1, result)
    ]
]

; --- Main Function: Merge (Wrapper) ---
fn merge(left_arr, right_arr) [
    ; Kick off the recursive process from index 0 with an empty result array []
    return recursive_merge_step(left_arr, 0, right_arr, 0, [])
]

; --- Main Function: Merge Sort (The 'Divide' and 'Conquer' Step) ---
fn merge_sort(arr) [
    arr_len = length(arr)
    
    ; Base Case: An array of 0 or 1 element is considered sorted.
    if (arr_len <= 1) [
        return arr
    ]
    
    ; 1. Divide: Find the midpoint (integer division)
    mid = arr_len / 2 
    
    ; 2. Divide: Split the array into two halves using native slicing: arr[start:end]
    left_half = arr[0:mid]       
    right_half = arr[mid:arr_len]
    
    ; 3. Conquer: Recursively sort the two halves
    sorted_left = merge_sort(left_half)
    sorted_right = merge_sort(right_half)
    
    ; 4. Combine: Merge the two sorted halves back together
    return merge(sorted_left, sorted_right)
]

; --- Execution ---
print("Original Array:")
print(data_array)

sorted_data = merge_sort(data_array)

print("\nSorted Array (Merge Sort):")
print(sorted_data)